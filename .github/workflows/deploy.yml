name: 🚀 Build e Deploy para Nexus

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      deploy_only:
        description: '🚀 Apenas deploy (pular testes e build)'
        required: false
        default: false
        type: boolean

env:
  IMAGE_NAME: tempo-box
  IMAGE_TAG: ${{ github.sha }}
  NEXUS_REGISTRY: ${{ secrets.NEXUS_REPOSITORY }}:${{ secrets.NEXUS_PORT }}
  AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
  # Cache paths para self-hosted runner
  GRADLE_USER_HOME: /home/apolo/.gradle
  GRADLE_CACHE_DIR: /home/apolo/.gradle-cache/${{ github.repository }}
  DOCKER_CACHE_DIR: /home/apolo/.docker-cache/${{ github.repository }}
  # Build artifacts cache local
  BUILD_CACHE_DIR: /etc/dev/cache/${{ github.repository }}/build-${{ github.run_id }}

jobs:
  # 🧪 Job 1: Testes
  test:
    name: 🧪 Executar Testes
    runs-on: [self-hosted, a3s-ubt-srv-maranguape-01]
    if: ${{ !inputs.deploy_only }}
    
    steps:
    - name: 📥 Checkout do código
      uses: actions/checkout@v4

    - name: ☕ Configurar JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: 📦 Configurar diretórios de cache do Gradle
      run: |
        echo "🔧 Configurando cache persistente do Gradle..."
        mkdir -p ${{ env.GRADLE_CACHE_DIR }}/caches
        mkdir -p ${{ env.GRADLE_CACHE_DIR }}/wrapper
        mkdir -p ${{ env.GRADLE_USER_HOME }}
        
        # Criar symlinks para cache persistente se não existirem
        if [ ! -L "${{ env.GRADLE_USER_HOME }}/caches" ]; then
          ln -sf ${{ env.GRADLE_CACHE_DIR }}/caches ${{ env.GRADLE_USER_HOME }}/caches
        fi
        if [ ! -L "${{ env.GRADLE_USER_HOME }}/wrapper" ]; then
          ln -sf ${{ env.GRADLE_CACHE_DIR }}/wrapper ${{ env.GRADLE_USER_HOME }}/wrapper
        fi
        
        echo "✅ Cache do Gradle pronto em ${{ env.GRADLE_CACHE_DIR }}"

    - name: 🔧 Tornar gradlew executável
      run: chmod +x ./gradlew

    - name: 🧪 Executar testes
      run: ./gradlew test --parallel --build-cache

    - name: 📊 Upload dos resultados dos testes
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: build/reports/tests/test/
        retention-days: 7

  # 🏗️ Job 2: Build da Aplicação
  build:
    name: 🏗️ Build da Aplicação
    runs-on: [self-hosted, a3s-ubt-srv-maranguape-01]
    needs: [test]
    if: always() && (needs.test.result == 'success' || inputs.deploy_only)
    
    steps:
    - name: 📥 Checkout do código
      uses: actions/checkout@v4

    - name: ☕ Configurar JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: 📦 Configurar diretórios de cache do Gradle
      run: |
        echo "🔧 Usando cache persistente do Gradle..."
        mkdir -p ${{ env.GRADLE_CACHE_DIR }}/caches
        mkdir -p ${{ env.GRADLE_CACHE_DIR }}/wrapper
        mkdir -p ${{ env.GRADLE_USER_HOME }}
        
        # Usar cache existente via symlinks
        if [ ! -L "${{ env.GRADLE_USER_HOME }}/caches" ]; then
          ln -sf ${{ env.GRADLE_CACHE_DIR }}/caches ${{ env.GRADLE_USER_HOME }}/caches
        fi
        if [ ! -L "${{ env.GRADLE_USER_HOME }}/wrapper" ]; then
          ln -sf ${{ env.GRADLE_CACHE_DIR }}/wrapper ${{ env.GRADLE_USER_HOME }}/wrapper
        fi
        
        echo "✅ Cache do Gradle vinculado, tamanho: $(du -sh ${{ env.GRADLE_CACHE_DIR }} 2>/dev/null || echo 'vazio')"

    - name: 🔧 Tornar gradlew executável
      run: chmod +x ./gradlew

    - name: 🏗️ Build da aplicação
      run: ./gradlew build -x test --parallel --build-cache

    - name: 📦 Salvar artefatos do build no cache local
      run: |
        echo "📦 Salvando artefatos do build no cache local..."
        sudo mkdir -p ${{ env.BUILD_CACHE_DIR }}
        sudo chmod 755 ${{ env.BUILD_CACHE_DIR }}
        sudo chown $USER:$USER ${{ env.BUILD_CACHE_DIR }}
        cp -r build/libs/* ${{ env.BUILD_CACHE_DIR }}/
        echo "✅ Artefatos salvos em: ${{ env.BUILD_CACHE_DIR }}"
        ls -la ${{ env.BUILD_CACHE_DIR }}/

  # 🐳 Job 3: Build e Push do Docker
  docker:
    name: 🐳 Build e Push do Docker
    runs-on: [self-hosted, a3s-ubt-srv-maranguape-01]
    needs: [build]
    if: always() && needs.build.result == 'success'
    
    steps:
    - name: 📥 Checkout do código
      uses: actions/checkout@v4

    - name: 📦 Recuperar artefatos do build do cache local
      run: |
        echo "📦 Recuperando artefatos do build do cache local..."
        if [ -d "${{ env.BUILD_CACHE_DIR }}" ]; then
          mkdir -p build/libs/
          cp -r ${{ env.BUILD_CACHE_DIR }}/* build/libs/
          echo "✅ Artefatos recuperados de: ${{ env.BUILD_CACHE_DIR }}"
          ls -la build/libs/
        else
          echo "❌ Cache não encontrado em: ${{ env.BUILD_CACHE_DIR }}"
          exit 1
        fi

    - name: 🐳 Configurar Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: 🔐 Login no Nexus Docker Registry
      run: |
        echo "🔐 Fazendo login no Nexus Registry..."
        echo "${{ secrets.NEXUS_PASSWORD }}" | docker login ${{ env.NEXUS_REGISTRY }} -u "${{ secrets.NEXUS_USER }}" --password-stdin

    - name: 📦 Configurar cache do Docker
      run: |
        echo "🔧 Configurando cache persistente do Docker..."
        mkdir -p ${{ env.DOCKER_CACHE_DIR }}
        echo "✅ Cache do Docker pronto em ${{ env.DOCKER_CACHE_DIR }}"

    - name: 🏗️ Build da imagem Docker
      run: |
        echo "🏗️ Fazendo build das imagens Docker com cache persistente..."
        docker buildx build \
          --cache-from=type=local,src=${{ env.DOCKER_CACHE_DIR }} \
          --cache-to=type=local,dest=${{ env.DOCKER_CACHE_DIR }},mode=max \
          --build-arg AUTH_TOKEN="${{ env.AUTH_TOKEN }}" \
          --build-arg APP_VERSION="1.0.0" \
          --tag ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
          --tag ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          --load \
          .
        
        echo "📊 Tamanho do cache: $(du -sh ${{ env.DOCKER_CACHE_DIR }} 2>/dev/null || echo 'vazio')"

    - name: 🚀 Push das imagens Docker para o Nexus
      run: |
        echo "🚀 Enviando imagens para o Nexus..."
        docker push ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        docker push ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        echo "✅ Imagens enviadas com sucesso!"

  # 🧹 Job 4: Limpeza
  cleanup:
    name: 🧹 Limpeza
    runs-on: [self-hosted, a3s-ubt-srv-maranguape-01]
    needs: [docker]
    if: always()
    
    steps:
    - name: 🧹 Limpeza das imagens Docker locais e cache de build
      run: |
        echo "🧹 Limpando imagens Docker locais..."
        docker rmi ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} || true
        docker rmi ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:latest || true
        
        # Limpar apenas imagens dangling, manter cache
        docker image prune -f || true
        
        # Limpar cache de build desta execução
        echo "🧹 Limpando cache de build da execução..."
        sudo rm -rf ${{ env.BUILD_CACHE_DIR }} || true
        
        echo "📊 Tamanhos dos caches após limpeza:"
        echo "Gradle: $(du -sh ${{ env.GRADLE_CACHE_DIR }} 2>/dev/null || echo 'vazio')"
        echo "Docker: $(du -sh ${{ env.DOCKER_CACHE_DIR }} 2>/dev/null || echo 'vazio')"
        echo "✅ Limpeza concluída!"

  # 📊 Job 5: Resumo
  summary:
    name: 📊 Resumo da Pipeline
    runs-on: [self-hosted, a3s-ubt-srv-maranguape-01]
    needs: [test, build, docker, cleanup]
    if: always()
    
    steps:
    - name: 📊 Resumo da Pipeline
      run: |
        echo "🎉 Resumo da Execução da Pipeline"
        echo "================================"
        echo "🧪 Testes: ${{ needs.test.result || 'pulado' }}"
        echo "🏗️  Build: ${{ needs.build.result || 'pulado' }}"
        echo "🐳 Docker: ${{ needs.docker.result || 'pulado' }}"
        echo "🧹 Limpeza: ${{ needs.cleanup.result || 'pulado' }}"
        echo "================================"
        if [[ "${{ needs.docker.result }}" == "success" ]]; then
          echo "✅ Deploy realizado com sucesso! Imagens disponíveis em:"
          echo "📦 ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "📦 ${{ env.NEXUS_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        else
          echo "❌ Deploy falhou ou foi pulado"
        fi